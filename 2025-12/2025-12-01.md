### 2025-12-01 TIL

📘 TIL: Go のスライスはなぜ参照型として動くのか

■ 今日学んだこと：スライスの本質と値渡しの仕組み

Go のスライスは 「内部にポインタを持つ参照型」 であり、関数に値渡ししても 基礎配列は共有されるため、要素の変更が元のスライスに反映される。

⸻

◆ 1. スライスの内部構造

スライスは見た目は配列に似ているが、本体は次の 3 つだけで構成された 小さなヘッダ：
• ポインタ（基礎配列を指すアドレス）
• 長さ（len）
• 容量（cap）

実際のデータ（基礎配列）は別のメモリ領域に存在する。

⸻

◆ 2. なぜ関数に渡しても中身が変わるのか

スライスを関数に渡すとき、Go は「スライスヘッダだけ値渡し」する。

しかし、ヘッダが持つポインタは同じ基礎配列を指しているため：

s[0] = "変更"

のような要素の書き換えは 元のスライスにも反映される。

⸻

◆ 3. append の注意点

append は容量が足りない場合に 新しい配列を割り当てる。

s = append(s, newValue)

このとき、関数内部で作られた「新しいスライスヘッダ」は外側に反映されないため、
元のスライスに影響しない場合がある。
• 要素変更 → 反映される（基礎配列共有）
• append → 反映されない可能性がある（新配列作成）

⸻

◆ 4. 参照型と値型の違い（超重要）

● 参照型（ポインタ不要でも中身が共有される）
• slice
• map
• channel
• function
• pointer

👉 内部にポインタを保持しているため、コピーしても参照先は同じ。

● 値型（struct はここ！）
• int, float, string, bool
• struct

👉 コピーされるため、元のデータを変更するにはポインタが必要。

⸻

■ まとめ（覚えるべき最重要ポイント）

1. スライス＝「ヘッダ（ポインタ＋ len ＋ cap）＋基礎配列」
2. スライスを渡すと ヘッダはコピーされるが、基礎配列は共有される
3. だから要素変更は元にも効く
4. ただし append は新配列を作ることがあり、元に反映されない
5. スライス／マップ／チャネルは参照型、構造体は値型

以下　オライリー　初めての Go 言語より
go fmt を使用すると、コードを整形できる。

:= は関数の外では使えない。
変数の宣言を関数の外で行うのは避けるべき。データフローの理解を妨げる。
