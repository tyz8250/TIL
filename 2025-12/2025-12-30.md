# http

``` go
package main

import (
    "fmt"
    "net/http"
)

func handler(w http.ResponseWriter, r *http.Request) {
    // r = リクエストの情報, w = レスポンスの情報
    fmt.Fprintf(w, "Hello, World!")
}

func main() {
    http.HandleFunc("/", handler)
    http.ListenAndServe(":8080", nil)
}
```

•「8080番ポートでHTTPサーバを起動する」
•「/ に来たリクエストはこの関数が処理する」

Goのnet/httpは内部でTCPを使っていて、
自分はHTTPの処理だけを書けばよい。

①curl すると何が起きる？
curl が TCP 接続を張り HTTP リクエストを送る。
Go の ListenAndServe がそれを受け取り、
パスに対応する handler を呼ぶ。

②HTTPはTCPの上に乗っている、の正しい説明
最初の私の答え：OSI参照モデルを考えたときに、TCPのほうが順位が下

正しい言い方：HTTPはアプリケーション層のプロトコルで、TCP（トランスポート層）の　　
　　　　　　　通信を利用してデータを送受信している。

fmt.Fprint
%sは Printf で文字列を埋め込むための指定子。

go mod download :fork → clone したリポジトリの初期設定時(設計図どおり材料を集める)
    - go.mod に書いてある
    - 外部ライブラリ（cobra / testify / etc）
    - go mod download はコードを見ない
    - import されてるかどうかも見ない
    - go.mod に書いてあるものを全部取る

go mod tidy:設計図そのものを掃除する
    今のコードを解析して
    - 使っていない依存関係を削除
    - 足りない依存関係を追加
    - go.mod / go.sum を整理
tidy は「依存関係を意図通りに整理したい時」に使う
