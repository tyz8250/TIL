### 2025-11-30 TIL

Go の Struct メソッドで値が更新されない理由

■ 今日学んだこと

Go の構造体メソッドでフィールドを書き換えても、元の値が更新されないことがある。その原因は 「値レシーバ（value receiver）」を使用しているため だった。

⸻

■ 例：値が変更されないコード

```go
func main() {
jim := person{
firstName: "Jim",
lastName: "Party",
contactInfo: contactInfo{
email: "jim@gmail.com",
zipCode: 94000,
},
}

    jim.updateName("Jimmy")
    jim.print() // → Jim のまま

}

func (p person) updateName(newFirstName string) {
p.firstName = newFirstName
}
```

⸻

■ 理由：値レシーバは「コピー」を受け取る

(p person) と書くと、jim の コピー が p に渡される。
• p.firstName = ... はコピー上での書き換え
• 元の jim のメモリ領域は変わらない
• そのため変更が反映されない

Go はデフォルトが「値渡し」なので、構造体も同じ。

⸻

■ 解決方法：ポインタレシーバを使う

```go
func (p \*person) updateName(newFirstName string) {
p.firstName = newFirstName
}
```

呼び出し側は変更不要：

jim.updateName("Jimmy")

Go が自動で &jim を渡してくれる。

⸻

■ なぜポインタだと変更されるのか？
• ポインタレシーバは 構造体のメモリアドレスを受け取る
• コピーではなく元のデータを指す
• そのアドレスの内容を直接書き換えるため、変更が反映される

⸻

■ 今日のまとめ
• Go のメソッドで構造体を更新したい場合は ポインタレシーバ（＊T） を使う
• 値レシーバ（T）はコピーが渡されるため、変更は元に反映されない
• 「RAM が影響」ではなく、「値渡しの仕様」が原因

⸻

型　値渡しで渡されたとき　中身は変わる？　なぜ
構造体　完全コピーされる ❌ 変わらない 実体をコピーするから
スライス スライスヘッダはコピーされるが実体配列は共有 ⭕ 変わる 内部ポインタが同じ配列を見るから
スライスの長さ/容量の変更 スライスヘッダがコピーの中だけで変わる ❌ 変わらないことがある append により新配列が作られるため
